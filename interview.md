# 总结

## 对比

`vue & react`掩盖底层的DOM操作,用声明式的方式来描述目的,使代码更易维护.

从`性能`上说,没有任何框架可以比手动优化的DOM操作更快,因为框架的DOM操作需要应对任意可能产生的情况,它的实现必须是普适的,`虚拟DOM`也并不比原生操作DOM更快.

**框架提供的是,在不需要手动优化的情况下,依然可以提供过得去性能.**

### VS JQuery

命令式的代码书写方式,手动操作DOM,告诉浏览器开发者要做什么.

从`MVVM`开始,对于视图的操作变成了更简单方便的声明式操作,基于数据驱动,视图根据数据来渲染,开发者无需关心底层实现,而更多的关注上层业务.

### VS MVVM

观察数据变化并保留对实际DOM的引用,当有数据变化时进行对应的操作.

+ 脏检查
  + 任何小变动所有监听都会触发,重新进行检查是否需要更新
+ 依赖收集
  + 初始化和数据变化的时候都需要重新收集依赖

`渲染列表`的时候,由于每一行都有自己的数据作用域,都有自己的实例,当数据变更时,无法重用之前的实例和DOM节点,需要销毁之前所有的实例,重新创建每行新的实例,最后在渲染.

而`虚拟DOM`的变动检查是基于DOM结构层面的,即使是全新的数据,只要渲染结构不变,那么就不需要做无用功.

### VS React

`React`的基本思想是每次有变动就重新渲染整个应用,为了避免直接使用innerHtml进行重置,所以使用`虚拟DOM`.

## 构建版本

+ 完整版
+ 运行时版本

`完整版`: 同时包含编译器和运行时的版本
`编译器`: 用来将模板字符串编译成为 JavaScript 的 render 函数代码.
`运行时`: 创建实例,渲染,虚拟DOM等(除编译器以外的一切)

若需要在`客户端编译模板`,需要使用`完整版`,在代码执行阶段进行编译.

若使用`vue-loader`的时候,在构建阶段将模板预编译为`JavasScript`,只使用`运行时版本`即可.

若使用`webpack`时即使用vue-loader也需要在运行时编译模板,则需要在打包工具中对`完整版`配置`别名`,或者使用时引用完整版的路径.

```javascript
module.exports = {
  // ...
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js'
    }
  }
}

// OR

import Vue$ from "vue/dist/vue.esm";
```
